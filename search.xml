<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LOJ6684]]></title>
    <url>%2FLOJ6684%2F</url>
    <content type="text"><![CDATA[无标号“奇树”计数。 原问题就是在问：黑白染色的树，叶子都是黑色，同色点不允许连边。无标号意义下含有$n$个黑点的黑根树的个数。 假设白根树个数为$f_n$，黑根树为$g_n$，很容易列出下面的式子: f_n=[x^n]\prod_{i=1}^{\infty}(\sum_{j=0}^{\infty}x^j)^{g_i}\\ g_n=[x^n]x\prod_{i=1}^{\infty}(\sum_{j=0}^{\infty}x^j)^{f_i}随手化简一下： f_n=\frac{\sum_{i=0}^{n-1}\sum_{j=1}^{n}[j|n-i]jg_j}{n}\\ g_n=\frac{\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[j|n-i]jf_j}{n-1}那么就可以分治$NTT$求解了，复杂度$O(nlog^2n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define I inline int#define V inline void#define ll long long int#define FOR(i,a,b) for(re int i=a;i&lt;=b;i++)#define ROF(i,a,b) for(re int i=a;i&gt;=b;i--)const int N=1&lt;&lt;19|1,mod=998244353,inv2=mod+1&gt;&gt;1;int n,m,ans;int f[N],g[N],h[N],X[N],Y[N],fa[N],ga[N];I Pow(ll t,int x)&#123; re ll s=1; while(x)&#123; if(x&amp;1)s=s*t%mod; t=t*t%mod,x&gt;&gt;=1; &#125; return s;&#125;int lmt=1,w[N],r[N];V init()&#123; int l=0;n&lt;&lt;=1; while(lmt&lt;=n)lmt&lt;&lt;=1,++l; FOR(i,1,lmt-1)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); int wn=Pow(3,(mod-1)&gt;&gt;l);w[lmt&gt;&gt;1]=1; FOR(i,(lmt&gt;&gt;1)+1,lmt-1)w[i]=(ll)w[i-1]*wn%mod; ROF(i,(lmt&gt;&gt;1)-1,1)w[i]=w[i&lt;&lt;1]; lmt=__builtin_ctz(lmt),n&gt;&gt;=1;&#125;I getLen(int n)&#123;return 1&lt;&lt;(32-__builtin_clz(n));&#125;V DFT(int*a,int l)&#123; static unsigned long long int tmp[N]; re int u(lmt-__builtin_ctz(l)),t; FOR(i,0,l-1)tmp[i]=a[r[i]&gt;&gt;u]; for(re int i=1;i&lt;l;i&lt;&lt;=1) for(re int j=0,step=i&lt;&lt;1;j&lt;l;j+=step) FOR(k,0,i-1) t=tmp[i+j+k]*w[i+k]%mod,tmp[i+j+k]=tmp[j+k]+mod-t,tmp[j+k]+=t; FOR(i,0,l-1)a[i]=tmp[i]%mod;&#125;V IDFT(int*a,int l)&#123; reverse(a+1,a+l),DFT(a,l); re int bk(mod-(mod-1)/l); FOR(i,0,l-1)a[i]=(ll)a[i]*bk%mod;&#125;I get_len(int l)&#123;return 1&lt;&lt;(32-__builtin_clz(l));&#125;V init(const int&amp;x)&#123; if(x^1)&#123; g[x]=1ll*g[x]*Pow(x-1,mod-2)%mod; f[x]=(1ll*x*g[x]+ga[x]+f[x])%mod; f[x]=1ll*f[x]*Pow(x,mod-2)%mod; &#125; else f[x]=g[x]=1; for(re int j=x,t=1ll*f[x]*x%mod;j&lt;=n;j+=x)fa[j]=(fa[j]+t)%mod; for(re int j=x,t=1ll*g[x]*x%mod;j&lt;=n;j+=x)ga[j]=(ga[j]+t)%mod;&#125;V mul(int l)&#123; DFT(X,l),DFT(Y,l); FOR(i,0,l-1)X[i]=1ll*X[i]*Y[i]%mod; IDFT(X,l);&#125;V cl(int l)&#123;memset(X,0,l&lt;&lt;2),memset(Y,0,l&lt;&lt;2);&#125;V cdq(int L,int R)&#123; if(L==R)return init(L); re int mid=L+R&gt;&gt;1,l; cdq(L,mid); if(L==1)&#123; l=get_len(R-L); FOR(i,L,mid)X[i-L]=f[i],Y[i-L]=ga[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=g[i],Y[i-L]=fa[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); &#125; else&#123; l=get_len(R+mid-L-L+1); FOR(i,L,mid)X[i-L]=f[i]; FOR(i,1,R-L)Y[i-1]=ga[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=ga[i]; FOR(i,1,R-L)Y[i-1]=f[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=g[i]; FOR(i,1,R-L)Y[i-1]=fa[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=fa[i]; FOR(i,1,R-L)Y[i-1]=g[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); &#125; cdq(mid+1,R);&#125;int main()&#123; cin&gt;&gt;n,m=n,n=get_len(n),init(),cdq(1,n),n=m; FOR(i,1,n)std::cout&lt;&lt;g[i]&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>分治NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础博弈论学习笔记]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这里记录了一些最基本的博弈论问题以及解决方式 定义组合游戏的意义如下： $1$、两个玩家L,R进行博弈。 $2$、每一回合，双方可选的合法操作有限。 $3$、对于任意一组合法局面，当前决策与之前的操作无关。 $4$、最后总能到达一种状态使得至少有一方的可操作性集合为0，这时游戏结束。 在这基础上加上一些别的条件，就组成了不同种类的组合游戏。 其中主要分为回合制与非回合制两种。 可以证明，回合制组合游戏总是存在最优纯策略：即每一步都有一种确定最优的决策方式。 而非回合制组合游戏不一定存在纯策略，但一定存在最优的混合策略，即以一定的概率随机的选择一种决策。 一般来讲，纯策略是混合策略的特殊情况。因为混合策略涉及到概率，所以通常与纯策略的博弈问题有着不同的处理方式。 回合制有向图游戏在组合游戏的基础上，增加条件： $1$、双方交替进行操作，每次操作与当前的玩家无关。 $2$、最先无法进行合法操作的一方判负。 所以有向图游戏是存在纯策略的博弈问题，因此可以使用对抗搜索解决，或者使用SG函数解决。 SG函数对于游戏的每个子游戏，存在一种衡量局面优劣的函数SG函数，整个游戏的SG函数就是各个子游戏的异或和。 每个局面的SG函数为当前局面的后继状态的SG函数集合中最小的没有出现的非负整数，可以发现对于某一状态而言： $1$、如果没有后继状态，SG函数为0，表示必败。 $2$、如果后继状态中存在必败状态，那么SG函数为正，表示必胜。 $3$、如果后继状态全是必胜，那么SG函数为0，表示必败。 这和对抗搜索的想法完全一致，只不过SG函数提供了量化的方法，因此允许快速合并多个子局面。 e.g. P2197 Nim游戏n堆石子，每人每次选择一堆至少取走一颗，问先手是否有必胜策略。 Nim游戏的各个子游戏的SG函数值就是石子个数(想一想，为什么)，然后异或起来看是不是0就行了。 为什么是异或？看这个，有各种解释，群论、线性基、还有我的瞎搞 非回合制零和博弈在组合游戏的基础上，增加条件： $1$、每一步操作会对某一方带来收益，同时让另一方支付代价。任意时刻，双方的收益和为0。 在这里如果双方交替操作的话，就一定存在纯策略，那就可以用对抗搜索解决。但是如果是同时操作，就一般不存在纯策略作为最优决策，问题就变成了混合决策问题。 所谓混合决策，就是一方的最优策略是以不同概率使用不同的决策。 对于每种局面，首先画出对应的收益矩阵$E=[e_{ij}]_{n\times{m}}$，在这里假设玩家1（叫做L）有n种不同的决策，玩家2（叫做R）有m种不同的决策，$e_{ij}$就表示当L选择i决策，R选择j决策时L的收益，这个矩阵就叫L的收益矩阵，R的收益矩阵就是$E[-e_{ji}]_{m\times{n}}$。 设玩家L选取各个决策的概率为$\begin{Bmatrix}l_1,l_2,l_3,…,l_n\end{Bmatrix}$。 玩家R选取各个决策的概率为$\begin{Bmatrix}r_1,r_2,r_3,…,r_n\end{Bmatrix}$。 双方的目标都是最大化己方的收益，最大化对方的支出。 感觉上，一方的最优策略应该满足：无论对方怎么选择决策，己方的收益都不会小于某个值，而对方的收益都不会大于某个值。 当一方采用最优策略时，另一方无论怎么调整都不会是收益更大。 这个概念叫做纳什平衡，有兴趣的话可以去查一下百科。 双方都采用最优策略时的收益叫做收益矩阵的值，双方的决策方式叫做平衡点。 求解收益矩阵由上述可知，一方的任意策略满足在任意情况下收益都不会低于某个值，而最优策略使得这一值最大化。 设该值为$V(V&gt;0)$。 问题就变成了： \sum_{i=1}^n l_i=1\sum_{i=1}^nl_i e_{ij}\geq V求此时$V$的最大取值。 第一个式子就是各个决策的概率和为1，第二个式子表示在极端情况下（R碰巧采用了针对己方混合策略的最优纯策略）也能保证收益，因为在R使用各个纯策略的情况下都能最大化最小收益，所以j是要从1枚举到m的。 设$L_i=\frac{l_i}{V}$，问题就变成了： \sum_{i=1}^nL_i e_{ij}\geq 1\text{求}\begin{Bmatrix}\sum_{i=1}^n L_i\end{Bmatrix}_{min}或者变个形式： \sum_{i=1}^n-L_i e_{ij}\leq 1\text{求}\begin{Bmatrix}\sum_{i=1}^n -L_i\end{Bmatrix}_{max}这就是一个标标准准的线性规划问题了。 对于非零和博弈的话，就不存在纳什平衡，因为纳什平衡只适用于非合作性博弈问题当中，自然不能用收益矩阵求解。 反过来说，只要是非合作性博弈问题就可以使用这种方法，而不仅仅限于零和博弈问题了。 e.g. P4232 无意识之外的捉迷藏两个人在一个$n$个点的$DAG$上走，两人走到同一节点时游戏结束，或者游戏到了$T$时刻没有结束，游戏视作在$T+1$时刻结束。每一时刻双方同时走一步，可以走到用有向边相连的相邻节点处。 设游戏结束时刻为$t_0$，一方收益为$t_0$，另一方收益为$-t_0$。 双方都采用最优策略时，求游戏的期望结束时间。$n,T\leq 20$ 这个是求收益矩阵的模板了，状态$f[i,j,k]$表示一个人在$i$点，一个人在$j$点，时刻为k的期望还有多久结束，每一个状态的后继状态就是遍历两点的所有出边，然后构造并求解收益矩阵即可。 不平等回合制博弈不平等博弈就是在组合游戏上追加： $1$、双方交替进行操作，最先不能操作的一方判负。 $2$、双方的决策不一定完全相同。 在处理不平等博弈的时候，除了利用其纯策略的性质而使用万能的对抗搜索之外，还有一种有力工具就是$Surreal\ Number$(超现实数)。 $Surreal\ Number$（下面内容大部分来自 方展鹏《浅谈如何解决不平等博弈问题》，这里只是一个简单的概述，即根据自己的理解组成的不完整但是够用的内容） $1$、一个超现实数由两个集合组成$\begin{Bmatrix}L|R\end{Bmatrix}$，每个集合要么为空，要么是由若干个超现实数组成的集合。 $2$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix}$，$y=\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}$，当且仅当不存在$x_i\in{X_L}$使得$y\leq x_i$并且不存在$y_i\in{Y_R}$使得$y_i\leq x$。 这些定义都是递归给出的，值得注意的是这里的$\leq$不是指小于等于，而是类似于集合中的偏序概念。不过之后会说到，超现实数集合是一个全序集，所以理解成小于等于也未尝不可。 然后通过下面的达利函数，我们可以构建出有理数与超现实数的对应关系： \delta(x)=\begin{cases}\begin{Bmatrix}|\end{Bmatrix},x=0\\\begin{Bmatrix}\delta(x-1)|\end{Bmatrix},x>0,x\in Z\\\begin{Bmatrix}|\delta(x+1)\end{Bmatrix},x0\\\end{cases}解释一下这个第四条，就是左右两个数加在一起取个平均数。 基本定理$1$、对于$x=\begin{Bmatrix}L|R\end{Bmatrix}$,有$L_{max}\leq x\leq R_{min}$，$x=\begin{Bmatrix}L_{max}|R_{min}\end{Bmatrix}$ $2$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix},y=\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}$: $\qquad x+y=\begin{Bmatrix}X_L|X_R\end{Bmatrix}+\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}=\begin{Bmatrix}X_L+y,x+Y_L|X_R+y,x+Y_R\end{Bmatrix}$ $3$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix}$,有$-x=\begin{Bmatrix}-X_R|-X_L\end{Bmatrix}$ 与不平等博弈的关系如果游戏$G$等价于$x=\begin{Bmatrix}L|R\end{Bmatrix}$，其中两个集合表示两个玩家的决策所产生的的后继状态集合： $x&gt;0 \ L$必胜，$x&lt;0 \ R$必胜，$x=0$后手必胜。 $x&gt;0$时：$L$先手时总能将$x$转移到一个大于等于0的状态，$R$先手只能将其转移到大于0的状态。轮到$L$时恒有$x&gt;0$，左集合始终不为空，$L$必胜。 $x&lt;0$时同理。 $x=0$时，$L$先手会将局面变成$x0$，然后同上。 将一个游戏的多个子游戏合并就是将其对应的$Surreal\ Number$对应的值相加。 e.g.Procrastination$n$个有黑白正方体堆成的柱子，先手只能拿白色，后手只能拿黑色。每人每次选择一个柱子拿走一个对应颜色的正方体，然后将该正方体上面的所有正方体（包括这个）全部拿走。一方不能操作时判负，判断先手是否存在必胜策略。 $n,h_i\leq 50$，$h_i$表示第$i$个柱子的高度。 根据定义$O(n)$递推然后相加即可，就是从下向上维护双方决策的最值，或者按照论文中的做法推式子。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
</search>
