<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高斯整数学习笔记]]></title>
    <url>%2F%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$cz$_$xuyixuan$太厉害了！！！ 经典结论证明定义$E(n)$为范数等于$n$的高斯函数个数，则有: E(n)=4\times\sum_{k|n}\chi(k)其中$\chi(x)$为模$4$意义下的狄利克雷非主特征。 证明： 引理1： 若$p$为质数，则有$(p-1)!\equiv -1\pmod p$。 证明： $p=2$时显然成立，考虑$p$为奇质数的情况。 除了单位根$1,-1$，其余的数在模意义下与其逆元在$[2,p-2]$中两两匹配，所以这些数对答案不产生贡。因此： (p-1)!\equiv 1*(p-1)\equiv-1\pmod p得证。 引理2： 如果质数$p$满足$p\equiv 1\pmod 4$，那么一定存在整数$x$，满足$p|x^2+1$。 证明： 由引理$1$可知，$(p-1)!+1\equiv 0\pmod p$ 将$\prod_{i=1}^{p-1}i$分成两半，易得： 1\times 2\equiv (p-1)\times(p-2)\pmod p3\times 4\equiv (p-3)\times(p-4)\pmod p\frac{p-3}{2}\times\frac{p-1}{2}\equiv (p-\frac{p-3}{2})\times(p-\frac{p-1}{2})\equiv \frac{p+3}{2}\times\frac{p+1}{2}\pmod p因此： \prod_{i=1}^{\lfloor p/2\rfloor}i\equiv\prod_{i=\lfloor p/2\rfloor+1}^{p-1}i\pmod p(\frac{p-1}{2}!)^2+1\equiv (p-1)!+1\equiv 0\pmod p得证。 定理1：(费马平方和定理) 奇质数$p$能分解成两个正整数$a,b$的平方和$a^2+b^2=p$当且仅当$p\equiv 1\pmod4$，且在不计$a,b$次序的情况下分解方式唯一。 费马平方和定理包含三个部分，我们分别证明一下。 $(1)$ $4k+3$型质数不能写成两个正整数的平方和。 $a^2\equiv 0,1\pmod 4$，则$a^2+b^2\equiv 0,1,2\pmod 4$。不存在模$4$等于$3$的情况，因此$(1)$得证。 这个也顺便证明了$4k+3$型的质数是高斯质数。 $(2)$ $4k+1$型质数能写成两个正整数的平方和。 由引理$2$可知，存在$x$满足$p|x^2+1$，即$p|(x+i)(x-i)$。 如果$p$是一个高斯质数，那么就会有$p|x+i$或$p|x-i$。但$\frac{x\pm i}{p}$并非高斯整数（虚部不是整数），所以假设不成立，$p$不是高斯整数。 设$p=uv(u,v\in\mathbb{Z})$，则有： p^2=N(p)=N(u)N(v)因为$p$为质数，所以必有$N(u)=N(v)=p$，而且因为$uv=p$，所以$u,v$共轭。若$u=a+bi,v=a-bi$，那么： p=uv=(a+bi)(a-bi)=a^2+b^2因此$(2)$得证。 $(3)$ 将$p$分解成两个正整数的平方和的本质不同方案唯一。 假设$p$有两种分解方式$p=a^2+b^2=c^2+d^2$，显然： (a+bi)(a-bi)=(c+di)(c-di)a+bi|(c+di)(c-di)若$a+bi$ 为高斯质数，那么$a+bi|c+di$或$a+bi|c-di$，而$N(a+bi)=N(c+di)=N(c-di)$，所以$a+bi$必定与其中一个相伴。同理，可以得到$a-bi$也与其中一个相伴，那么$p=a^2+b^2=c^2+d^2$本质相同。 若$a+bi$不是高斯质数，则设$a+bi=uv(u,v\in\mathbb{Z[i]},N(u),N(v)&gt;1)$。 p=(a+bi)(a-bi)=uv\times\overline{uv}=(u\overline{u})\times(v\overline{v})因为范数大于$1$的共轭高斯整数相乘得到大于$1$的正整数，就相当于能将$p$分解成两个大于$1$的正整数相乘，与$p$为质数矛盾。 因此$(3)$得证。 因此费马平方和定理得证。 回到一开始需要证明的东西上去，根据范数的定义，可以发现$E(n)$表示的是将$n$分解成$a^2+b^2$的方案总数，也可以看作是分解成两个共轭的高斯整数相乘$(a+bi)(a-bi)$的方案数。 这里假设只统计本质不同的分解方案$f(n)$，即去掉了所有相伴的分解方案。考虑将分解结果分别乘上单位元的贡献，有$E(n)=4f(n)$。 设$n=\prod p_i^{k_i}$，其中$p_i$为质数。 尝试将每个质数分解成共轭的质数。 对$p_i=2$，只有$2=(1-i)(1+i)$一种本质不同的分解方案，$k_i$的取值会影响方案数。 对$p_i=4k+3$，因为$4k+3$型质数为高斯质数，无法分解，所以只有$2|k_i$时有唯一的分解方案$p_i^{k_i/2}\times p_i^{k_i/2}$。 对$p_i=4k+1$，因为$p_i^{k_i}=(a+bi)^{k_i}(a-bi)^{k_i}$，所以有$(a+bi)^{p}(a-bi)^{p}\times(a+bi)^{k_i-p}(a-bi)^{k_i-p},(p\in[0,k_i])$共$k_i+1$种分解方案。 综合一下，可以得到： f(n)=\prod \begin{cases} 1&p_i=2\\\\ k_i+1& p_i=4k+1\\\\ [p_i\equiv 0 \pmod 2] & p_i=4k+3 \end{cases}那么考虑一下模$4$意义下的狄利克雷非主特征$\chi(x)$的定义： \chi(x)= \begin{cases} 1 & x\equiv 1\pmod4\\\\ -1 & x\equiv 3\pmod4\\\\ 0 & default \end{cases}对于$p_i=2$，有： \chi(p_i^{x})= \begin{cases} 1&x=0\\\\ 0&x>0 \end{cases}因此 \sum_{j=0}^{k_i}\chi(p_i^{j})=1对于$p_i=4k+1$，有： \chi(p_i^x)=1因此 \sum_{j=0}^{k_i}\chi{p_i^j}=k_i+1对于$p_i=4k+3$，有： \chi(p_i^x)= \begin{cases} 1&x\equiv 0\pmod2\\\\ -1&x\equiv 1\pmod2 \end{cases}因此 \sum_{j=0}^{k_i}\chi(p_i^j)=[k_i\equiv0\pmod2]又因为$\chi(x)$为完全积性函数，所以： \sum_{i|n}\chi(i)=\prod_{i}(\sum_{j=0}^{k_i}\chi(p_i^j))=f(n)根据最开始的定义，带入则有： E(n)=4\times\sum_{i}\chi(i)=4f(n)则该结论得证。 推论因为平面直角坐标系上的整点可以用$\mathbb{Z}[i]$表示，那么$E(n)$就可以表示距离原点距离为$\sqrt{n}$的整点个数。 如果统计一个圆心在原点处，半径为$R$的圆内有多少个整点，就相当于求$1+\sum_{i=1}^{R^2}E(i)$。 对于后半部分，用我们已知的结论展开： \sum_{i=1}^{R^2}E(i)=4\times\sum_{i=1}^{R^2}\sum_{j|i}\chi(j)交换求和顺序，原式就可以转化为： 4\times\sum_{j}^{R^2}\chi(j)\times\lfloor\frac{R^2}{j}\rfloor考虑一下当$R$趋向于无穷大的时候，向下取整以及加$1$的误差都可以忽略不计。又因为用圆内的整点数描述圆的面积在$R$趋向无穷大的时候也可以忽略不计，所以： \pi R^2=4\times R^2\sum_{j}\frac{\chi(j)}{j}这里取了等号是因为当$R$趋向无穷大的时候等式两边的误差可以达到任意小。 约去$R^2$，再代入$\chi(x)$的取值： \pi=4\times(1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\frac{1}{9}-\cdots)而右边的无穷级数正是收敛于$\pi$的，这也从另一个角度验证了上述推导的正确性。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯特林数学习笔记]]></title>
    <url>%2F%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[斯特林数入门资料。 第一类斯特林数： 定义：n个不同元素排成m个圆排列的方案数。 无符号:$S_u(n,m)$ 有符号:$S_s(n,m)=(-1)^{n+m}S_u(n,m)$ 表示法： {[x]_{n}}=x(x-1)(x-2)...(x-n+1)=\sum^{n}_{k=0}{s}_{s}(n,k)x^k{[x]^{n}}=x(x+1)(x+2)...(x+n-1)=\sum^{n}_{k=0}{s}_{u}(n,k)x^k{s}_{u}(n,m)=\begin{bmatrix}n\\m \end{bmatrix}递推式： \begin{bmatrix}n\\m \end{bmatrix}=\begin{bmatrix}n-1\\m-1 \end{bmatrix}+(n-1)\cdot \begin{bmatrix}n-1\\m \end{bmatrix}一些性质： \begin{bmatrix}0\\0 \end{bmatrix}=1,\begin{bmatrix}n\\0 \end{bmatrix}=0,\begin{bmatrix}n\\n \end{bmatrix}=1,\begin{bmatrix}n\\1 \end{bmatrix}=(n-1)!,\begin{bmatrix}n\\n-1 \end{bmatrix}=C_{n}^{2}\begin{bmatrix}n\\2 \end{bmatrix}=(n-1)! \cdot \sum_{i=1}^{n-1} \frac{1}{i}\begin{bmatrix}n\\n-2 \end{bmatrix}=2 \cdot C_n^3+3\cdot C_n^4第二类斯特林数:记作$S(n,m)$或$\begin{Bmatrix}n\\m \end{Bmatrix}$ \begin{Bmatrix}n\\m \end{Bmatrix}=\begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m \cdot \begin{Bmatrix}n-1\\m \end{Bmatrix}含义：将n个不同元素拆成m个集合的方案数。 \begin{Bmatrix}n\\m \end{Bmatrix}=\frac{1}{m!}\sum_{k=0}^{m}(-1)^k C_m^k (m-k)^n性质：暂坑（抄百科抄累了） \begin{Bmatrix}n\\m\end{Bmatrix}=0 (n]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ6684]]></title>
    <url>%2FLOJ6684%2F</url>
    <content type="text"><![CDATA[无标号“奇树”计数。 原问题就是在问：黑白染色的树，叶子都是黑色，同色点不允许连边。无标号意义下含有$n$个黑点的黑根树的个数。 假设白根树个数为$f_n$，黑根树为$g_n$，很容易列出下面的式子: f_n=[x^n]\prod_{i=1}^{\infty}(\sum_{j=0}^{\infty}x^j)^{g_i}\\ g_n=[x^n]x\prod_{i=1}^{\infty}(\sum_{j=0}^{\infty}x^j)^{f_i}随手化简一下： f_n=\frac{\sum_{i=0}^{n-1}\sum_{j=1}^{n}[j|n-i]jg_j}{n}\\ g_n=\frac{\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[j|n-i]jf_j}{n-1}那么就可以分治$NTT$求解了，复杂度$O(nlog^2n)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define I inline int#define V inline void#define ll long long int#define FOR(i,a,b) for(re int i=a;i&lt;=b;i++)#define ROF(i,a,b) for(re int i=a;i&gt;=b;i--)const int N=1&lt;&lt;19|1,mod=998244353,inv2=mod+1&gt;&gt;1;int n,m,ans;int f[N],g[N],h[N],X[N],Y[N],fa[N],ga[N];I Pow(ll t,int x)&#123; re ll s=1; while(x)&#123; if(x&amp;1)s=s*t%mod; t=t*t%mod,x&gt;&gt;=1; &#125; return s;&#125;int lmt=1,w[N],r[N];V init()&#123; int l=0;n&lt;&lt;=1; while(lmt&lt;=n)lmt&lt;&lt;=1,++l; FOR(i,1,lmt-1)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); int wn=Pow(3,(mod-1)&gt;&gt;l);w[lmt&gt;&gt;1]=1; FOR(i,(lmt&gt;&gt;1)+1,lmt-1)w[i]=(ll)w[i-1]*wn%mod; ROF(i,(lmt&gt;&gt;1)-1,1)w[i]=w[i&lt;&lt;1]; lmt=__builtin_ctz(lmt),n&gt;&gt;=1;&#125;I getLen(int n)&#123;return 1&lt;&lt;(32-__builtin_clz(n));&#125;V DFT(int*a,int l)&#123; static unsigned long long int tmp[N]; re int u(lmt-__builtin_ctz(l)),t; FOR(i,0,l-1)tmp[i]=a[r[i]&gt;&gt;u]; for(re int i=1;i&lt;l;i&lt;&lt;=1) for(re int j=0,step=i&lt;&lt;1;j&lt;l;j+=step) FOR(k,0,i-1) t=tmp[i+j+k]*w[i+k]%mod,tmp[i+j+k]=tmp[j+k]+mod-t,tmp[j+k]+=t; FOR(i,0,l-1)a[i]=tmp[i]%mod;&#125;V IDFT(int*a,int l)&#123; reverse(a+1,a+l),DFT(a,l); re int bk(mod-(mod-1)/l); FOR(i,0,l-1)a[i]=(ll)a[i]*bk%mod;&#125;I get_len(int l)&#123;return 1&lt;&lt;(32-__builtin_clz(l));&#125;V init(const int&amp;x)&#123; if(x^1)&#123; g[x]=1ll*g[x]*Pow(x-1,mod-2)%mod; f[x]=(1ll*x*g[x]+ga[x]+f[x])%mod; f[x]=1ll*f[x]*Pow(x,mod-2)%mod; &#125; else f[x]=g[x]=1; for(re int j=x,t=1ll*f[x]*x%mod;j&lt;=n;j+=x)fa[j]=(fa[j]+t)%mod; for(re int j=x,t=1ll*g[x]*x%mod;j&lt;=n;j+=x)ga[j]=(ga[j]+t)%mod;&#125;V mul(int l)&#123; DFT(X,l),DFT(Y,l); FOR(i,0,l-1)X[i]=1ll*X[i]*Y[i]%mod; IDFT(X,l);&#125;V cl(int l)&#123;memset(X,0,l&lt;&lt;2),memset(Y,0,l&lt;&lt;2);&#125;V cdq(int L,int R)&#123; if(L==R)return init(L); re int mid=L+R&gt;&gt;1,l; cdq(L,mid); if(L==1)&#123; l=get_len(R-L); FOR(i,L,mid)X[i-L]=f[i],Y[i-L]=ga[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=g[i],Y[i-L]=fa[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); &#125; else&#123; l=get_len(R+mid-L-L+1); FOR(i,L,mid)X[i-L]=f[i]; FOR(i,1,R-L)Y[i-1]=ga[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=ga[i]; FOR(i,1,R-L)Y[i-1]=f[i];mul(l); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=g[i]; FOR(i,1,R-L)Y[i-1]=fa[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); FOR(i,L,mid)X[i-L]=fa[i]; FOR(i,1,R-L)Y[i-1]=g[i];mul(l); FOR(i,mid+1,R)g[i]=(g[i]+X[i-L-1])%mod;cl(l); &#125; cdq(mid+1,R);&#125;int main()&#123; cin&gt;&gt;n,m=n,n=get_len(n),init(),cdq(1,n),n=m; FOR(i,1,n)std::cout&lt;&lt;g[i]&lt;&lt;'\n'; return 0;&#125;]]></content>
      <categories>
        <category>做题记录</category>
      </categories>
      <tags>
        <tag>多项式</tag>
        <tag>分治NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础博弈论学习笔记]]></title>
    <url>%2F%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这里记录了一些最基本的博弈论问题以及解决方式 定义组合游戏的意义如下： $1$、两个玩家L,R进行博弈。 $2$、每一回合，双方可选的合法操作有限。 $3$、对于任意一组合法局面，当前决策与之前的操作无关。 $4$、最后总能到达一种状态使得至少有一方的可操作性集合为0，这时游戏结束。 在这基础上加上一些别的条件，就组成了不同种类的组合游戏。 其中主要分为回合制与非回合制两种。 可以证明，回合制组合游戏总是存在最优纯策略：即每一步都有一种确定最优的决策方式。 而非回合制组合游戏不一定存在纯策略，但一定存在最优的混合策略，即以一定的概率随机的选择一种决策。 一般来讲，纯策略是混合策略的特殊情况。因为混合策略涉及到概率，所以通常与纯策略的博弈问题有着不同的处理方式。 回合制有向图游戏在组合游戏的基础上，增加条件： $1$、双方交替进行操作，每次操作与当前的玩家无关。 $2$、最先无法进行合法操作的一方判负。 所以有向图游戏是存在纯策略的博弈问题，因此可以使用对抗搜索解决，或者使用SG函数解决。 SG函数对于游戏的每个子游戏，存在一种衡量局面优劣的函数SG函数，整个游戏的SG函数就是各个子游戏的异或和。 每个局面的SG函数为当前局面的后继状态的SG函数集合中最小的没有出现的非负整数，可以发现对于某一状态而言： $1$、如果没有后继状态，SG函数为0，表示必败。 $2$、如果后继状态中存在必败状态，那么SG函数为正，表示必胜。 $3$、如果后继状态全是必胜，那么SG函数为0，表示必败。 这和对抗搜索的想法完全一致，只不过SG函数提供了量化的方法，因此允许快速合并多个子局面。 e.g. P2197 Nim游戏n堆石子，每人每次选择一堆至少取走一颗，问先手是否有必胜策略。 Nim游戏的各个子游戏的SG函数值就是石子个数(想一想，为什么)，然后异或起来看是不是0就行了。 为什么是异或？看这个，有各种解释，群论、线性基、还有我的瞎搞 非回合制零和博弈在组合游戏的基础上，增加条件： $1$、每一步操作会对某一方带来收益，同时让另一方支付代价。任意时刻，双方的收益和为0。 在这里如果双方交替操作的话，就一定存在纯策略，那就可以用对抗搜索解决。但是如果是同时操作，就一般不存在纯策略作为最优决策，问题就变成了混合决策问题。 所谓混合决策，就是一方的最优策略是以不同概率使用不同的决策。 对于每种局面，首先画出对应的收益矩阵$E=[e_{ij}]_{n\times{m}}$，在这里假设玩家1（叫做L）有n种不同的决策，玩家2（叫做R）有m种不同的决策，$e_{ij}$就表示当L选择i决策，R选择j决策时L的收益，这个矩阵就叫L的收益矩阵，R的收益矩阵就是$E[-e_{ji}]_{m\times{n}}$。 设玩家L选取各个决策的概率为$\begin{Bmatrix}l_1,l_2,l_3,…,l_n\end{Bmatrix}$。 玩家R选取各个决策的概率为$\begin{Bmatrix}r_1,r_2,r_3,…,r_n\end{Bmatrix}$。 双方的目标都是最大化己方的收益，最大化对方的支出。 感觉上，一方的最优策略应该满足：无论对方怎么选择决策，己方的收益都不会小于某个值，而对方的收益都不会大于某个值。 当一方采用最优策略时，另一方无论怎么调整都不会是收益更大。 这个概念叫做纳什平衡，有兴趣的话可以去查一下百科。 双方都采用最优策略时的收益叫做收益矩阵的值，双方的决策方式叫做平衡点。 求解收益矩阵由上述可知，一方的任意策略满足在任意情况下收益都不会低于某个值，而最优策略使得这一值最大化。 设该值为$V(V&gt;0)$。 问题就变成了： \sum_{i=1}^n l_i=1\sum_{i=1}^nl_i e_{ij}\geq V求此时$V$的最大取值。 第一个式子就是各个决策的概率和为1，第二个式子表示在极端情况下（R碰巧采用了针对己方混合策略的最优纯策略）也能保证收益，因为在R使用各个纯策略的情况下都能最大化最小收益，所以j是要从1枚举到m的。 设$L_i=\frac{l_i}{V}$，问题就变成了： \sum_{i=1}^nL_i e_{ij}\geq 1\text{求}\begin{Bmatrix}\sum_{i=1}^n L_i\end{Bmatrix}_{min}或者变个形式： \sum_{i=1}^n-L_i e_{ij}\leq 1\text{求}\begin{Bmatrix}\sum_{i=1}^n -L_i\end{Bmatrix}_{max}这就是一个标标准准的线性规划问题了。 对于非零和博弈的话，就不存在纳什平衡，因为纳什平衡只适用于非合作性博弈问题当中，自然不能用收益矩阵求解。 反过来说，只要是非合作性博弈问题就可以使用这种方法，而不仅仅限于零和博弈问题了。 e.g. P4232 无意识之外的捉迷藏两个人在一个$n$个点的$DAG$上走，两人走到同一节点时游戏结束，或者游戏到了$T$时刻没有结束，游戏视作在$T+1$时刻结束。每一时刻双方同时走一步，可以走到用有向边相连的相邻节点处。 设游戏结束时刻为$t_0$，一方收益为$t_0$，另一方收益为$-t_0$。 双方都采用最优策略时，求游戏的期望结束时间。$n,T\leq 20$ 这个是求收益矩阵的模板了，状态$f[i,j,k]$表示一个人在$i$点，一个人在$j$点，时刻为k的期望还有多久结束，每一个状态的后继状态就是遍历两点的所有出边，然后构造并求解收益矩阵即可。 不平等回合制博弈不平等博弈就是在组合游戏上追加： $1$、双方交替进行操作，最先不能操作的一方判负。 $2$、双方的决策不一定完全相同。 在处理不平等博弈的时候，除了利用其纯策略的性质而使用万能的对抗搜索之外，还有一种有力工具就是$Surreal\ Number$(超现实数)。 $Surreal\ Number$（下面内容大部分来自 方展鹏《浅谈如何解决不平等博弈问题》，这里只是一个简单的概述，即根据自己的理解组成的不完整但是够用的内容） $1$、一个超现实数由两个集合组成$\begin{Bmatrix}L|R\end{Bmatrix}$，每个集合要么为空，要么是由若干个超现实数组成的集合。 $2$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix}$，$y=\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}$，当且仅当不存在$x_i\in{X_L}$使得$y\leq x_i$并且不存在$y_i\in{Y_R}$使得$y_i\leq x$。 这些定义都是递归给出的，值得注意的是这里的$\leq$不是指小于等于，而是类似于集合中的偏序概念。不过之后会说到，超现实数集合是一个全序集，所以理解成小于等于也未尝不可。 然后通过下面的达利函数，我们可以构建出有理数与超现实数的对应关系： \delta(x)=\begin{cases}\begin{Bmatrix}|\end{Bmatrix},x=0\\\begin{Bmatrix}\delta(x-1)|\end{Bmatrix},x>0,x\in Z\\\begin{Bmatrix}|\delta(x+1)\end{Bmatrix},x0\\\end{cases}解释一下这个第四条，就是左右两个数加在一起取个平均数。 基本定理$1$、对于$x=\begin{Bmatrix}L|R\end{Bmatrix}$,有$L_{max}\leq x\leq R_{min}$，$x=\begin{Bmatrix}L_{max}|R_{min}\end{Bmatrix}$ $2$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix},y=\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}$: $\qquad x+y=\begin{Bmatrix}X_L|X_R\end{Bmatrix}+\begin{Bmatrix}Y_L|Y_R\end{Bmatrix}=\begin{Bmatrix}X_L+y,x+Y_L|X_R+y,x+Y_R\end{Bmatrix}$ $3$、对于$x=\begin{Bmatrix}X_L|X_R\end{Bmatrix}$,有$-x=\begin{Bmatrix}-X_R|-X_L\end{Bmatrix}$ 与不平等博弈的关系如果游戏$G$等价于$x=\begin{Bmatrix}L|R\end{Bmatrix}$，其中两个集合表示两个玩家的决策所产生的的后继状态集合： $x&gt;0 \ L$必胜，$x&lt;0 \ R$必胜，$x=0$后手必胜。 $x&gt;0$时：$L$先手时总能将$x$转移到一个大于等于0的状态，$R$先手只能将其转移到大于0的状态。轮到$L$时恒有$x&gt;0$，左集合始终不为空，$L$必胜。 $x&lt;0$时同理。 $x=0$时，$L$先手会将局面变成$x0$，然后同上。 将一个游戏的多个子游戏合并就是将其对应的$Surreal\ Number$对应的值相加。 e.g.Procrastination$n$个有黑白正方体堆成的柱子，先手只能拿白色，后手只能拿黑色。每人每次选择一个柱子拿走一个对应颜色的正方体，然后将该正方体上面的所有正方体（包括这个）全部拿走。一方不能操作时判负，判断先手是否存在必胜策略。 $n,h_i\leq 50$，$h_i$表示第$i$个柱子的高度。 根据定义$O(n)$递推然后相加即可，就是从下向上维护双方决策的最值，或者按照论文中的做法推式子。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每月一题2019.8]]></title>
    <url>%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E9%A2%982019.8%2F</url>
    <content type="text"><![CDATA[统计半径为$n$的圆内整点个数，$n\leq 10^{18}$。 题面 用$Stern-Brocot-Tree$可以很方便地处理这一类问题。 用折线拟合函数有两个要求： $1$、函数是个凹函数。 $2$、函数可以快速求导。 对于圆而言，只需要统计第一象限内的整点个数。 为了使函数转化成凹函数，就将其旋转$180$度，就变成了凹函数，然后容斥计算即可。 这时圆的解析式就变成了$(x-n)^2+(y-n)^2=n^2$。 随手写成：$y=n+\sqrt{2nx-x^2}$。 求个导：$\frac{n-x}{\sqrt{2nx-x^2}}$。 那么就可以愉快地计算了，复杂度$O(n^{1/3})$。]]></content>
      <categories>
        <category>每月一题</category>
      </categories>
      <tags>
        <tag>SternBrocotTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每月一题2019.7]]></title>
    <url>%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E9%A2%982019.7%2F</url>
    <content type="text"><![CDATA[集训时出的水题（每月一题越来越水）。 题面 假设这个二叉搜索树内的节点权值为$[1,n]$。 那么我们可以发现一个有趣的性质就是该二叉搜索树中的每个子树内的值域都是连续的。 所以可以设计出状态$f_{i,j,k,p}$表示值域$[i,j]$构成的红黑树的黑高度为k,根为红或黑色的情况下红黑树的种数。 每次枚举当前的红黑树的根的权值以及颜色，可以写出一个$O(n^4)$的dp: 设$f_{i,j,k,2}=f_{i,j,k,0}+f_{i,j,k,1}$ f_{i,j,k,0}=\sum_{p=i}^{j}f_{i,p-1,k-1,2}*f_{p+1,j,k-1,2}f_{i,j,k,1}=\sum_{p=i}^{j}f_{i,p-1,k,0}*f_{p+1,j,k,0}又观察到实际上没有必要枚举值域的范围，只需要知道红黑树的大小就可以进行上面的dp，那么可以省去一维状态。 又因n个节点的红黑树树高为$[\lfloor \frac{log_2 n}{2}+1\rfloor,\lfloor log_2 (n+1) \rfloor ]$，第二维的状态总数实际上只有$O(logn)$种。 那么我们就得到了一个$O(n^2logn)$的算法。 进一步观察得到的两个dp方程,还是设$f_{i,j,2}=f_{i,j,0}+f_{i,j,1}$。 f_{i,j,0}=\sum_{k=1}^{i}f_{k-1,j-1,2}*f_{i-k,j-1,2}f_{i,j,1}=\sum_{k=1}^{i}f_{k-1,j,0}*f_{i-k,j,0}这是一个卷积的形式，那么对于答案的第二维做一遍卷积dp就可以得到答案了。复杂度$O(nlog^2 n)$，可以通过。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define rnt re int#define re register#define I inline int#define V inline void#define ll long long int#define FOR(i,A,B) for(rnt i(A),_ed(B);i&lt;=_ed;i++)#define ROF(i,A,B) for(rnt i(A),_ed(B);i&gt;=_ed;i--)const int N=1&lt;&lt;19|1,mod=998244353,G=3,inv3=332748118,inv2=499122177;I Pow(re ll t,rnt x)&#123; re ll s=1; while(x)&#123; if(x&amp;1)s=s*t%mod; x&gt;&gt;=1,t=t*t%mod; &#125; return s;&#125;namespace poly&#123; int lmt(1),r[N],w[N]; V init(rnt n)&#123; rnt l=0; while(lmt&lt;=n)lmt&lt;&lt;=1,++l; FOR(i,1,lmt-1)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); rnt wn=Pow(3,mod&gt;&gt;l);w[lmt&gt;&gt;1]=1; FOR(i,(lmt&gt;&gt;1)+1,lmt-1)w[i]=(ll)w[i-1]*wn%mod; ROF(i,(lmt&gt;&gt;1)-1,1)w[i]=w[i&lt;&lt;1]; lmt=__builtin_ctz(lmt); &#125; I getLen(rnt n)&#123;return 1&lt;&lt;(32-__builtin_clz(n));&#125; V DFT(int*a,rnt l)&#123; static unsigned long long int tmp[N]; rnt u(lmt-__builtin_ctz(l)),t; FOR(i,0,l-1)tmp[i]=a[r[i]&gt;&gt;u]; for(rnt i=1;i&lt;l;i&lt;&lt;=1) for(rnt j=0,step=i&lt;&lt;1;j&lt;l;j+=step) FOR(k,0,i-1)&#123; t=tmp[i+j+k]*w[i+k]%mod; tmp[i+j+k]=tmp[j+k]+mod-t; tmp[j+k]+=t; &#125; FOR(i,0,l-1)a[i]=tmp[i]%mod; &#125; V IDFT(int*a,rnt l) &#123; reverse(a+1,a+l),DFT(a,l); rnt bk(mod-mod/l); FOR(i,0,l-1)a[i]=(ll)a[i]*bk%mod; &#125;&#125;int n,m,ans;int f[2][20][N],tmp[N];V input()&#123;cin&gt;&gt;n,m=31-__builtin_clz(n+1);&#125;V init()&#123;poly::init(n+n+3);&#125;V work()&#123; int l=poly::getLen(n+n+3); f[0][0][0]=f[1][0][1]=1; FOR(j,1,m)&#123; FOR(i,0,n)tmp[i]=(f[0][j-1][i]+f[1][j-1][i])%mod; poly::DFT(tmp,l); FOR(i,0,l-1)tmp[i]=1ll*tmp[i]*tmp[i]%mod; poly::IDFT(tmp,l); FOR(i,1,n)f[0][j][i]+=tmp[i-1]; FOR(i,0,l-1)tmp[i]=0; FOR(i,0,n)tmp[i]=f[0][j][i]%mod; poly::DFT(tmp,l); FOR(i,0,l-1)tmp[i]=1ll*tmp[i]*tmp[i]%mod; poly::IDFT(tmp,l); FOR(i,1,n)f[1][j][i]+=tmp[i-1]; FOR(i,0,l-1)tmp[i]=0; &#125; FOR(i,0,m)ans=(ans+f[0][i][n])%mod; cout&lt;&lt;ans;&#125;int main()&#123; input(); init(); work(); return 0;&#125;]]></content>
      <categories>
        <category>每月一题</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每月一题2019.6]]></title>
    <url>%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E9%A2%982019.6%2F</url>
    <content type="text"><![CDATA[题面： 输出n个点的形态不同的森林对998244353取模的结果。 题解： 这是经典题诶，主要考察会不会真正的分治FFT啦。 设n个点的无标号有根树有$f_n$个，对应的生成函数为$F(x)$。 对于一棵树而言，去掉根节点之后的各个部分互不关联，又因为没有标号，所以可以看作是一个背包的关系。那么枚举与根相连的子树大小，将背包的生成函数套进去： f_n=[x^n]x\prod_{k=1}^{\infty}(\sum_{i=0}^{\infty}x^{ik})^{f_k}这个式子就相当于枚举大小为$k$的子树，因为大小为$k$的子树有$f_k$种选法，每一种有都有无限多个，所以总贡献是右边那一堆东西。而这个总贡献有没有计算根的大小，那么就再在左边乘上一个$x$。 熟悉生成函数的话，就可以话建议下右边的部分： F(x)=[x^n]x\prod_{k=1}^{\infty}(1-x^k)^{-f_k}这个时候$[x^n]$就可以拿掉了： F(x)=x\prod_{k=1}^{\infty}(1-x^k)^{-f_k}连乘转连加的话就是$\ln$了吧，那么就对数： \ln{F(x)}=\ln{x}-\sum_{k=1}^{\infty}\ln(1-x^k)对数不好处理，求导： \frac{F(x)'}{F(x)}=\frac{1}{x}+\sum_{k=1}^{\infty}kf_k\frac{x^{k-1}}{1-x^k}两边同时乘上$xF(x)$，去掉分母： xF(x)'=F(x)+F(x)\sum_{k=1}^{\infty}kf_k\frac{x^k}{1-x^k}放$[x^n]$上去： nf_n=f_n+\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k([x^{n-i}]\frac{x^k}{1-x^k})因为有： \frac{x^k}{1-x^k}=\sum_{i=1}^{\infty}x^{ik}=\sum_{i=1}^{\infty}[k|i]x^i所以可以带入原式： nf_n=f_n+\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k[k|n-i]转化一下： f_n=\frac{\sum_{i=1}^{n-1}f_i\sum_{k=1}^{n-1}kf_k[k|n-i]}{n-1}将右边的部分当做另一个多项式的$n-i$项，那么这就是一个类似卷积的形式，考虑用分治$FFT$优化。 基于调和级数，已知$F(x)$的话暴力计算右边的辅助多项式(设为$G(x)$)的复杂度只有$O(nlogn)$，那么就只用考虑如何计算分治时左边对右边的贡献。 因为$G(x)$的位数不够，当分治的左端点不为$1$时左区间对右边的贡献不能完全计算。所以就先不计算这部分的贡献，改为在计算出一段$G(x)$后卷积两次来完整计算左区间的贡献（一遍$F(x)$一遍$G(x)$）。 具体实现的时候为了计算贡献时的方便就将位数补到$2^k$不然非常难写。 现在已经求出了$n$个点的无标号有根树的数量，考虑使用容斥转化出为标号无根树的数量。 因为一棵树的重心非常少并且可以用子树大小来描述，那么就使用容斥去掉所有根不为重心的子树，具体来说就是枚举有哪些树的根包含一个子树的大小大于整棵树大小的一半就可以解决了。 实际实现的时候考虑枚举断掉原来树的一条中心边来处理，下面假设$h_n$为$n$的无标号无根树的数量。 h_n=\begin{cases}f_n-\sum_{k=(n+1)/2}^{n-1}f_kf_{n-k},[2\nmid n]\\f_n-\sum_{k=n/2+1}^{n-1}f_kf_{n-k}-\binom{f_{n/2}}{2},[2\mid n]\end{cases}因为偶数个节点的树可能有两个重心，枚举判掉即可。 那么这个东西的中间的部分很明显是一个卷积，$O(nlogn)$求出来然后$O(n)$加加减减就可以求出$\{h_n\}$。 然后现在知道了无标号的树的数量，怎么计算无标号森林的数量呢？ 一颗森林由若干棵树组成，互相之间没有影响，也没有顺序，那么就相当于一个背包:大小为$k$的物品有$h_k$种。 设恰好装成体积为$n$的方案数为$g_n$，其数列对应的形式幂级数为$G(x)$： G(x)=\prod_{k=1}^{\infty}(\sum_{i=0}^{\infty}x^{ik})^{h_k}非常眼熟对吧，那么就求$\ln$： \ln{G(x)}=\sum_{k=1}^{\infty}h_k\ln(\frac{1}{1-x^k})而又因为： \ln(\frac{1}{1-x^k})=\int dx\frac{(\frac{1}{1-x^k})'}{\frac{1}{1-x^k}}\qquad\qquad=\int dx(1-x^k)\sum_{i=1}^{\infty}ikx^{ik-1}\qquad\qquad=\int dx\sum_{i=1}^{\infty}kx^{ik-1}\qquad\qquad=\sum_{i=1}^{\infty}\frac{1}{i}x^{ki}基于调和级数，这个东西是可以$O(nlogn)$暴力计算出来的，那么就可以求出$\ln{G(x)}$，再做一个$\exp$就可以求出$G(x)$了。 总复杂度$O(nlog^2n)$，但是因为分治FFT的小常数跑起来相当快。 下面是代码环节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1&lt;&lt;19|1,mod=998244353,G=3,inv3=332748118,inv2=mod+1&gt;&gt;1;#define re register#define I inline int#define V inline void#define ll long long int#define FOR(i,A,B) for(re int i=A;i&lt;=B;++i)#define ROF(i,A,B) for(re int i=A;i&gt;=B;--i)ll Pow(ll t,int x)&#123; ll s=1; for(;x;x&gt;&gt;=1,t=t*t%mod) if(x&amp;1)s=s*t%mod; return s;&#125;namespace poly&#123; int lmt(1),r[N],w[N],inv[N]; V init(int n)&#123; int l=0;inv[0]=inv[1]=1; FOR(i,2,n)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod; while(lmt&lt;=n)lmt&lt;&lt;=1,++l; FOR(i,1,lmt-1)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); int wn=Pow(3,(mod-1)&gt;&gt;l);w[lmt&gt;&gt;1]=1; FOR(i,(lmt&gt;&gt;1)+1,lmt-1)w[i]=(ll)w[i-1]*wn%mod; ROF(i,(lmt&gt;&gt;1)-1,1)w[i]=w[i&lt;&lt;1]; lmt=__builtin_ctz(lmt); &#125; I getLen(int n)&#123;return 1&lt;&lt;(32-__builtin_clz(n));&#125; V DFT(int*a,int l)&#123; static unsigned long long int tmp[N]; re int u(lmt-__builtin_ctz(l)),t; FOR(i,0,l-1)tmp[i]=a[r[i]&gt;&gt;u]; for(re int i=1;i&lt;l;i&lt;&lt;=1) for(re int j=0,step=i&lt;&lt;1;j&lt;l;j+=step) FOR(k,0,i-1) t=tmp[i+j+k]*w[i+k]%mod,tmp[i+j+k]=tmp[j+k]+mod-t,tmp[j+k]+=t; FOR(i,0,l-1)a[i]=tmp[i]%mod; &#125; V IDFT(int*a,int l)&#123; reverse(a+1,a+l),DFT(a,l); re int bk(mod-(mod-1)/l); FOR(i,0,l-1)a[i]=(ll)a[i]*bk%mod; &#125; V get_inv(const int*a,int*b,int n)&#123; if(n==1)return void(b[0]=Pow(a[0],mod-2)); static int tmp[N],l; get_inv(a,b,(n+1)&gt;&gt;1),l=getLen(n&lt;&lt;1); FOR(i,0,n-1)tmp[i]=a[i]; FOR(i,n,l-1)tmp[i]=0; DFT(tmp,l),DFT(b,l); FOR(i,0,l-1)b[i]=(2ll-1ll*tmp[i]*b[i]%mod+mod)%mod*b[i]%mod; IDFT(b,l);FOR(i,n,l-1)b[i]=0; &#125; V deri(const int*a,int*b,int n)&#123;FOR(i,0,n-2)b[i]=1ll*a[i+1]*(i+1)%mod;&#125; V inte(const int*a,int*b,int n)&#123;FOR(i,1,n-1)b[i]=1ll*a[i-1]*inv[i]%mod;&#125; V Ln(const int*a,int*b,int n)&#123; static int tmp[N],l; deri(a,b,n),get_inv(a,tmp,n),l=getLen(n&lt;&lt;1); DFT(b,l),DFT(tmp,l); FOR(i,0,l-1)tmp[i]=1ll*b[i]*tmp[i]%mod; IDFT(tmp,l);FOR(i,0,l-1)b[i]=0; inte(tmp,b,n);FOR(i,0,l-1)tmp[i]=0; &#125; V exp(const int*a,int*b,int n)&#123; static int tmp[N],l; if(n==1)return void(b[0]=1); exp(a,b,(n+1)&gt;&gt;1),Ln(b,tmp,n),l=getLen(n&lt;&lt;1); FOR(i,0,n-1)tmp[i]=(a[i]-tmp[i]+mod)%mod; FOR(i,n,l-1)tmp[i]=0; ++tmp[0],DFT(tmp,l),DFT(b,l); FOR(i,0,l-1)b[i]=1ll*tmp[i]*b[i]%mod; IDFT(b,l);FOR(i,n,l-1)b[i]=tmp[i]=tmp[i-n]=0; &#125;&#125;using poly::inv;using poly::DFT;using poly::IDFT;using poly::getLen;int f[N],g[N],n,m,k,h[N];V init(const int&amp;x)&#123; if(x^1)f[x]=1ll*f[x]*Pow(x-1,mod-2)%mod; else f[x]=1; for(re int j=x,t=1ll*f[x]*x%mod;j&lt;=n;j+=x)g[j]=(g[j]+t)%mod;&#125;#define mul() DFT(X,l),DFT(Y,l);FOR(i,0,l-1)X[i]=1ll*X[i]*Y[i]%mod;IDFT(X,l);V cdq(int L,int R)&#123; if(L==R)return init(L); static int X[N],Y[N]; re int mid=L+R&gt;&gt;1,l; cdq(L,mid); if(L==1)&#123; FOR(i,L,mid)X[i-L]=f[i],Y[i-L]=g[i]; l=getLen(R-L),mul(); FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod; FOR(i,0,l-1)X[i]=Y[i]=0; &#125; else&#123; l=getLen(R+mid-L-L+1); FOR(i,L,mid)X[i-L]=f[i]; FOR(i,1,R-L)Y[i-1]=g[i];mul() FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod; FOR(i,0,l-1)X[i]=Y[i]=0; FOR(i,L,mid)X[i-L]=g[i]; FOR(i,1,R-L)Y[i-1]=f[i];mul() FOR(i,mid+1,R)f[i]=(f[i]+X[i-L-1])%mod; FOR(i,0,l-1)X[i]=Y[i]=0; &#125; cdq(mid+1,R);&#125;int A[N],B[N],fac[N];int main()&#123; freopen("tree.in","r",stdin); freopen("tree.out","w",stdout); cin&gt;&gt;n,n++,m=n,n=getLen(n),poly::init(n),cdq(1,n),n=m; re int l=getLen(n+n); static int X[N]; FOR(i,0,l-1)X[i]=f[i]*(i&lt;=n);DFT(X,l); FOR(i,0,l-1)X[i]=1ll*X[i]*X[i]%mod;IDFT(X,l); FOR(i,1,n) if(i&amp;1)h[i]=(f[i]+mod-1ll*X[i]*inv2%mod)%mod; else X[i]=(X[i]-1ll*f[i&gt;&gt;1]*f[i&gt;&gt;1]%mod+mod)%mod, h[i]=((ll)f[i]+mod*2-1ll*X[i]*inv2%mod-(1ll*f[i&gt;&gt;1]*(f[i&gt;&gt;1]-1)&gt;&gt;1)%mod)%mod; FOR(i,1,n)FOR(j,1,n/i) A[j*i]=(A[j*i]+1ll*h[i]*inv[j]%mod)%mod; poly::exp(A,B,n),n--,cout&lt;&lt;B[n]; return 0;&#125; 实际上也不是很难对吧，在校内考试的时候出了这道题结果居然全员爆0了，出来个把人输出了样例之外大部分人甚至连源代码都没交233。 （明明$O(n^2)$很好想的$da\star{ze}$）]]></content>
      <categories>
        <category>每月一题</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学学习笔记]]></title>
    <url>%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天（2019.5.23）有幸能听到组合十段的陈通学长讲解组合数学知识。 \Huge\texttt{组}_{\texttt{合}^{\texttt{数}_\texttt{学}}}part1:组合数约定: x^{\underline{k}}=[x]_{k}=\prod_{i=n-k+1}^{n}ix^{\overline{k}}=[x]^{k}=\prod_{i=n}^{n+k-1}i\binom{n}{k}=\frac{[n]_{k}}{k!}则有： \binom{-1}{k}=(-1)^k\binom{-n}{k}=(-1)^k\binom{n+k-1}{k}二项式定理： (a+b)^n=\sum_{k\geq 0}\binom{n}{k}a^kb^{n-k}则有： (1+x)^k=\sum_{k\geq 0}\binom{n}{k}x^k\frac{1}{1+x}=\sum_{k\geq 0}(-x)^k\sum_{k\geq 0}\binom{n}{k}=2^n\sum_{k\geq 0}(-1)^k\binom{n}{k}=0\sum_{k\geq 0}\binom{n}{2k}=2^{n-1}\sum_{k\geq 0}\binom{n}{3k}=?将$x=w_3^0,w_3^1,w_3^2$带入$(1+x)^k$可以计算 （课后练习1:解决一类$\sum\binom{n}{ak}$的问题） fandemengde行列式： (1+x)^{n_1}*(1+x)^{n_2}=\sum_{k\geq 0}\sum_{i\geq 0}\binom{n_1}{i}\binom{n_2}{k-i}x^k=(1+x)^{n_1+n_2}=\sum_{k\geq 0}\binom{n_1+n_2}{k}x^kLucas定理： \binom{n}{m}\equiv \binom{n \mod{p}}{m\mod{p}}\cdot\binom{n/p}{m/p}\mod{p}证明： n=s*p+r(1+x)^n=[(1+x)^p]^s*(1+x)^r=(1+\binom{p}{1}x+\binom{p}{2}x^2+...+\binom{p}{p}x^p)^s*(1+x)^r\equiv(1+x^p)^s\cdot(1+x)^r\mod{p}之后再二项式转回去就ok了。 杨辉三角性质： \binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}\sum_{i=m}^{n}\binom{i}{k}=\binom{n+1}{m+1}-\binom{m}{k+1}\sum_{k=0}^{n}k\binom{n}{k}=\sum_{k=1}^{n}n\binom{n-1}{k-1}=n\sum_{k=0}^{n-1}\binom{n-1}{k}=n2^n\sum_{k=0}^{n}k^2\binom{n}{k}= \sum_{k=0}^{n}k^{\underline{2}}\binom{n}{k}+\sum_{k=0}^{n}k\binom{n}{k}=n(n-1)2^{n-1}+n2^ne.g.若$f(x)$为次数小于n的多项式，则有:$\sum_{k=0}^{n}(-1)^kf(k)\binom{n}{k}=0$ 考虑将普通多项式转化成下降幂多项式来证明(课后练习2)。 $Stirling$公式： n! \approx \sqrt{2\pi n}(\frac{n}{e})^n性质：$\binom{n}{n/2}\approx\frac{2^n}{\sqrt{n}}$ part2:生成函数生成函数是数列的另一种表达方式（形式幂级数） {$a_n$}的普通生成函数为$\sum_{n\geq 0}a_nx_n$ e.g.组合数对应的生成函数：$(1+x)^n=\sum_{k \geq 0}\binom{n}{k}x^k$ 阶乘的倒数对应的生成函数：$e^x=\sum_{k\geq 0}\frac{x^k}{k!}$ 生成函数求解递推：e.g.0求$Fibonacci$的通项公式： 令$F(x)=\sum_{k\geq 0}f_kx^k$ 则有$F(x)=1+x+x^2F(x)+x(F(x)-1)$ $F(x)=\frac{1}{1-x-x^2}=\frac{A}{1-\alpha x}+\frac{B}{1-\beta x}=…$ 后两项又是等比数列的生成函数，就可以得到通项公式了。 e.g.1考虑每个元素为1,2的n元组，求和为3的倍数的n元组个数。 设$F(X),g(x),h(x)$为模3余数为0,1,2的生成函数: $F(x)=1+xG(x)+xH(x)$ $G(x)=1+xF(x)+xH(x)$ $H(x)=1+xF(x)+xG(x)$ 得：$F(x)=\frac{1-x}{1-x-x^2}=\sum_{k\geq 0}(-1)^k\frac{2}{3}+\sum_{k\geq 0}\frac{1}{3}2^k$ 用生成函数求解通项公式的方法：用生成函数描述数列的递推公式，得到生成函数方程并求，然后将生成函数转回通项公式。 e.g.2考虑每个元素为0,1,2的n元组，求有奇数个1，偶数个2的n元组个数。 f_n=\sum_{i+j+k=n}[2\nmid j][2\mid k]\binom{n}{j}\binom{n-i}{k}\frac{f_n}{n!}=\sum_{i+j+k=n}[2\nmid j][2\mid k]\frac{n!}{i!j!k!}所以$f_n$的指数生成函数可以用三个函数的卷积来表示。 F(x)=e^x\cdot \frac{e^x-e^{-x}}{2}\cdot \frac{e^x+e^{-x}}{2}=\frac{e^{3x}-e^{-x}}{4}(后面两项就是阶乘奇数项与偶数项的生成函数) F(x)=\sum_{k\geq 0}\frac{3^n-(-1)^n}{4n!}x^n所以$f_n=\frac{3^n-(-1)^n}{4}$。 part3:catlan数定义：括号序列方案数。 递推公式： c_0=1,c_n=\sum_{i=0}^{n-1}c_ic_n-i-1生成函数： C(x)=\frac{1-\sqrt{1-4x}}{2x}通项公式： C(x)=\frac{(2n)!}{n!(n+1)!}part4:Stirling数这部分参见这一篇 part5:拆分数将n个相同的小球放入k个相同的盒子(非空)的方案数称作拆分数，记作$p(n,k)$。 如果不限定盒子的个数，则定义拆分数为$p(n)$。 性质： $p(n)&lt;p(n+1)$ $p(n)-p(n-1)&lt;p(n+1)-p(n)$ $p(2n,n)=p(n)$ Ferrers图把n拆成若干个正整数之和，其中最大值恰为k的方案数为$p(n,k)$。 可以利用这一结论dp求$p(n,k)$ 法1: dp[n][k]\rightarrow dp[n+k][k],dp[n][k]\rightarrow dp[n][k+1]法2: dp[n][k]\rightarrow dp[n+1][k+1],dp[n][k]\rightarrow dp[n+k][k]法3: $A=${$1,2,…,s$} $B=${$s+1,s+2,…n$} p(n)=\sum_{i=0}^{n}P_a(i)\cdot P_b(n-i)法4: 生成函数：$p(x)=\prod_{k\geq 1}\frac{1}{1-x^k}$ 法5: $p(x)=p(n-1)+p(n-2)-p(n-5)-p(n-7)$，其中项上减去的常数为广义的五边形数。 广义五边形数即为$(1-x)(1-x^2)(1-x^3)…$的系数。 即：$\sum_{k=0} (-1)^kx^{3k\pm{}1}$ 拆分数大小估计2^{\sqrt{n}-2}\leq p(n)\leq 2^{n-1}估计复杂度用，在十二省联考 希望 中间有所应用（暴力部分的复杂度分析）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每月一题2019.5]]></title>
    <url>%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E9%A2%982019.5%2F</url>
    <content type="text"><![CDATA[【模板】动态树链剖分 由于会不断插入新节点，所以无法做到保证树链剖分的结果最优。 这时有两个不使用点分树的思路。 一个是定义平衡因子$\alpha$，按照重量平衡（替罪羊树）的思想不断重构树剖，可以证得单次操作的摊还复杂度最坏情况下为$O(\frac{\alpha}{2\alpha-1}log_{\frac{1}{\alpha}}n)$。注意，这是插入一个节点需要的对点操作的期望复杂度，而树链剖分上的单点修改复杂度是$O(logn)$的，所以整体复杂度为两个log级别。经过计算，$\alpha$在取0.658时期望操作个数在$n=100000$时有最小$84$。 另一个做法就是将维护树链剖分的数据结构由线段树换成$FHQ treap$，这样就可以做到快速改换树剖的某一部分，但这样写还是会出现一些问题，比方说判断一个点在哪一条重链上就非常麻烦（但并非不能处理）。 这时，就会发现重链剖分的局限性：不便于修改。或者说，每次选择子树大小最大的子树确实能达到$O(logn)$的渐进复杂度下限，但是这并非是最优的树剖方法。举个例子，一坨菊花和一根没菊花那么大的链，重链剖分时会选择菊花，但是很明显选择链更优。 对于树剖的优秀程度有两种判断方式，一种方式是计算所有点到根要跳的距离和，另一种是所有点到根的距离的最大值。通常讨论最坏情况下的复杂度，所以选择第二种方式来评判树剖的优秀程度。 具体来说，定义一个节点的秩为子树内一个节点通过跳重链的方式跳到当前节点的次数。树链剖分的时候选择儿子中秩最大的一个作为重儿子，可以证明一个节点的秩为儿子中秩最大的节点的秩和次大的秩+1的最大值。换言之，至少要存在一个大小不小于当前子树的兄弟节点才能使当前节点向上的秩+1，这一点可以直接参考安置合并并查集的复杂的证明，最坏复杂度是$O(logn)$的，而且大概率跑不满。 而且与维护儿子重量平衡不同，维护儿子重量平衡的时候需要一直更新到根，因为可能在深度较大的节点处重量平衡但是在深度较浅的节点处重量不平衡。但是如果使用维护秩的方式来更新重儿子的话，一旦无法更新当前链的秩，也一定无法更新深度更浅的链。 因为整棵树的秩之和有一个上界为$\sum log(siz[u])=O(nlogn)$，所以插入一个节点的摊还复杂度有一上界为$O(logn)$。实际上，还可以使用构造法严格证明这一上界不仅是摊还的复杂度，更是单次操作的最坏复杂度。 但是还没完，修改不仅仅涉及到插入，还有删除操作，即将链的一段切割下来，在续接一段上去。同样，这里也有两种做法。 第一种非常的暴力，就是上面的用$FHQ treap$来做，实际上还有一些小优化，比方说将$treap$的随机权值设为深度的lowbit之类的。这要做总共需要$O(nlogn)$次操作，总复杂度$O(nlog^2n)$。 第二种更加暴力，就是单纯的暴力修改。当然，这样做的前提还是得基于复杂度分析。定义一个势函数为每个节点要成为重儿子要达到的秩的大小，同一条链的势相同并为为链顶的势。很显然的是整棵树每个节点的势函数值之和有上界$O(nlogn)$。每当一条链被断开，那么断开的这部分链的势能每个都+1，与操作次数线性相关。即单点修改次数最多为势能总数，即$O(nlogn)$。而单点修改的复杂度为$O(logn)$，所以总复杂度为$O(nlog^2n)$。 那么就可以大力进行修改了，信息也可以直接使用主席树来维护，时空复杂度$O(nlog^2n)$。]]></content>
      <categories>
        <category>每月一题</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每月一题2019.4]]></title>
    <url>%2F%E6%AF%8F%E6%9C%88%E4%B8%80%E9%A2%982019.4%2F</url>
    <content type="text"><![CDATA[题面 改编（魔改）自SNOI2017炸弹。 原题是链上的情况，这里我随手扩展到了平面上发现结果非常有趣。 先说结论，我只搞出了一个$O(nlog^2 n)$的做法，常数还大到飞起，不得不开2秒时限。 首先很明显，建图，缩点，dp。 原题的$O(n)$建图为单调栈，每个点的入边为左右两侧能炸到自己的最近点。 就是对每个$i$找满足以下条件： x_i \leqslant x_j+r_jx_j \leqslant x_i的$j$中$x_j$最大的$j$。 这是一个二维偏序问题，但是由于第二式子关于第一个式子有单调性，所以可以单调栈维护。 对于本题，则是像做二维曼哈顿距离最小生成树似的对8个方向做一遍。 即对每个$i$找满足以下条件： x_j \leqslant x_iy_j-x_j\leqslant y_i-x_ix_i+y_i\leqslant x_j+y_j+r_j的$j$中$x_j+y_j$最大的$j$。 这个三维偏序由于不存在相关的单调性所以没办法将某两维合并进行单调栈，所以只能老老实实cdq分治。 是的，$O(nlog^2 n)$的cdq分治做8遍，暴力吧。 然后建出来的图缩点，问题就变成了求一个dag上每个点出发能到达多少点。 不可以$O(n)$记搜，因为会重复，不过大样例我会好好地出成记搜能过的数据的。 使用线段树合并判重，因为总边数为$8n$，那么一个节点最多被判重$8$次，总复杂度为$O(8nlogn)=O(nlogn)$。 综上所述，问题可以在$O(nlog^2 n)$的时间与$O(nlogn)$的空间内解决。 难度大概略低于弱省省选，不过码量比较大，提高D2T3的样子。 （因为本地评测时如果开无限栈的话会奇慢无比，所以tarjan写了人工栈）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;char _buf[100010],*_op(_buf),*_ed(_buf);#define re register#define D inline ld#define I inline int#define ll long long#define LL inline ll#define B inline bool#define V inline void#define cr const run&amp;#define cb const bomb&amp;#define ld long double#define lowbit(x) (x&amp;-x)#define FOR(i,a,b) for(re int i=a;i&lt;=b;i++)#define f_pre for(re int i=x.p1;i;i-=lowbit(i))#define f_nxt for(re int i=x.p2;i&lt;=cnt;i+=lowbit(i))#define REP(i,u,v) for(re int i=h[u],v;v=e[i].t,i;i=e[i].n)#define gc _op==_ed&amp;&amp;(_op=_buf,_ed=fread(_buf,1,100000,stdin)+_buf,_op==_ed)?EOF:*_op++const int N=1e5+1,INF=0x7fffffff,mod=998244853;LL getint()&#123; ll _s=0,_f=1;char _ch=gc; while(_ch&lt;'0'||_ch&gt;'9')_f=(_ch=='-')?-1:1,_ch=gc; while(_ch&gt;='0'&amp;&amp;_ch&lt;='9')_s=_s*10+_ch-48,_ch=gc; return _s*_f;&#125;int n,h[N],tot;struct edge&#123;int t,n;&#125;e[N&lt;&lt;3];V add_edge(int x,int y)&#123;if(x&gt;0)e[++tot]=(edge)&#123;y,h[x]&#125;,h[x]=tot;&#125;namespace part1&#123;//cdq分治建图 int e1x,e1y,e2x,e2y,cnt; struct bomb&#123; ld x,y;int r,id,p1,p2; V input(int p)&#123;x=getint(),y=getint(),r=getint(),id=p;&#125; V init()&#123; ld X,Y; X=(x*e2y-y*e2x)/(e1x*e2y-e2x*e1y); Y=(x*e1y-y*e1x)/(e2x*e1y-e1x*e2y); x=X,y=Y; &#125; V turn(int opt)&#123; switch(opt)&#123; case 0:y=-y;break; case 1:x=-x;break; case 2:swap(x,y); &#125; &#125; &#125;a[N]; V input()&#123; n=getint(),e1x=getint(),e1y=getint(),e2x=getint(),e2y=getint(); FOR(i,1,n)a[i].input(i),a[i].init(); &#125; ld val[N&lt;&lt;1]; I find(ld x)&#123; int l=1,r=cnt,mid; while(mid=l+r&gt;&gt;1,l^r) if(val[mid+1]&lt;=x)l=mid+1; else r=mid; return mid; &#125; struct run&#123; int x,p1,p2,id; V clean()&#123;x=p1=p2=id=0;&#125; &#125;b[N],c[N],to[N],t[N&lt;&lt;1]; B cmp(cb x,cb y)&#123;return x.y-x.x==y.y-y.x?x.x&lt;y.x:x.y-x.x&lt;y.y-y.x;&#125; V add(cr x)&#123;f_pre if(t[i].id==0||t[i].p2&lt;x.p2)t[i]=x;&#125; V update(cr x)&#123;f_nxt if(to[x.id].id==0||to[x.id].p2&lt;t[i].p2)to[x.id]=t[i];&#125; V clean(cr x)&#123;f_pre t[i].clean();&#125; V cdq(int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1; cdq(l,mid),cdq(mid+1,r); int i=l,j=mid+1,cur=l; while(i&lt;=mid&amp;&amp;j&lt;=r) if(b[i].x&lt;=b[j].x)add(b[i]),c[cur++]=b[i++]; else update(b[j]),c[cur++]=b[j++]; while(i&lt;=mid)c[cur++]=b[i++]; while(j&lt;=r)update(b[j]),c[cur++]=b[j++]; FOR(k,l,r)clean(b[k]),b[k]=c[k]; &#125; V work()&#123; FOR(dir,1,8)&#123; FOR(i,1,n)to[i].clean(); if((dir&amp;3)^1)FOR(i,1,n)a[i].turn(dir&amp;1); else if(dir^1)FOR(i,1,n)a[i].turn(2); sort(a+1,a+1+n,cmp),cnt=0; FOR(i,1,n)val[++cnt]=a[i].x; sort(val+1,val+1+n),cnt=unique(val+1,val+1+n)-val-1; FOR(i,1,n)b[i].x=find(a[i].x),b[i].id=a[i].id;cnt=0; FOR(i,1,n)val[++cnt]=a[i].x+a[i].y+a[i].r; FOR(i,1,n)val[++cnt]=a[i].x+a[i].y; sort(val+1,val+1+cnt),cnt=unique(val+1,val+1+cnt)-val-1; FOR(i,1,n)b[i].p1=find(a[i].x+a[i].y+a[i].r),b[i].p2=find(a[i].x+a[i].y); cdq(1,n); FOR(i,1,n)add_edge(to[i].id,i); &#125; &#125; V MAIN()&#123;input(),work();&#125;&#125;namespace part2&#123;//tarjan缩点后线段树合并统计答案 int dfn[N],low[N],sta[N],ins[N],co[N],siz[N],rt[N],dp[N]; int up,top,qwq,TAT; struct run&#123;int u,i,v;&#125;st[N]; V tarjan(int k)&#123; st[++up]=(run)&#123;k,-1,0&#125;; run x; while(up)&#123; start:; x=st[up--]; if(x.i==-1)x.i=h[x.u],dfn[x.u]=low[x.u]=++qwq,sta[++top]=x.u,ins[x.u]=1; if(x.v)low[x.u]=min(low[x.u],low[x.v]),x.i=e[x.i].n; for(;x.v=e[x.i].t,x.i;x.i=e[x.i].n) if(!dfn[x.v])&#123; st[++up]=x,st[++up]=(run)&#123;x.v,-1,0&#125;; goto start; &#125; else if(ins[x.v])low[x.u]=min(low[x.u],dfn[x.v]); if(dfn[x.u]==low[x.u])&#123; co[x.u]=++TAT,siz[co[x.u]]++,ins[x.u]=0; while(sta[top]!=x.u)co[sta[top]]=co[x.u],siz[co[x.u]]++,ins[sta[top]]=0,top--; top--; &#125; &#125; &#125; struct bian&#123; int x,y; B operator==(const bian&amp;u)const&#123;return this-&gt;x==u.x&amp;&amp;this-&gt;y==u.y;&#125; &#125;b[N&lt;&lt;3]; B pp(const bian&amp;x,const bian&amp;y)&#123;return x.x==y.x?x.y&lt;y.y:x.x&lt;y.x;&#125; V clean()&#123;memset(h,0,sizeof(h)),tot=0;&#125; V maker()&#123; qwq=unique(b+1,b+1+qwq)-b-1; FOR(i,1,qwq)add_edge(b[i].x,b[i].y); &#125; #define lc t[p].ls #define rc t[p].rs #define lson lc,L,mid #define rson rc,mid+1,R struct ele&#123;int ls,rs,sum;&#125;t[N&lt;&lt;5]; V update(int p)&#123;t[p].sum=t[lc].sum+t[rc].sum;&#125; I merge(int p,int L,int R,int x)&#123; if(!p||!x)return x|p; if(L==R)return p; int mid=L+R&gt;&gt;1; lc=merge(lson,t[x].ls); rc=merge(rson,t[x].rs); update(p); return p; &#125; V dfs(int u)&#123; if(dp[u])return; REP(i,u,v)dfs(v),rt[u]=merge(rt[u],1,TAT,rt[v]); dp[u]=t[rt[u]].sum; &#125; V insert(int&amp;p,int L,int R,int x)&#123; if(p==0)p=++qwq; t[p].sum+=siz[x]; if(L==R)return; int mid=L+R&gt;&gt;1; if(x&gt;mid)insert(rson,x); else insert(lson,x); &#125; V work()&#123; FOR(i,1,n)if(!dfn[i])tarjan(i);qwq=0; FOR(i,1,n)REP(j,i,v)if(co[i]^co[v])b[++qwq]=(bian)&#123;co[i],co[v]&#125;; sort(b+1,b+1+qwq,pp),clean(),maker(),qwq=0; FOR(i,1,TAT)insert(rt[i],1,TAT,i); FOR(i,1,TAT)if(dp[i]==0)dfs(i); long long ans=0; FOR(i,1,n)ans+=1ll*dp[co[i]]*i,ans%=mod; cout&lt;&lt;ans&lt;&lt;'\n'; &#125;&#125;int main()&#123; freopen("bomb.in","r",stdin); freopen("bomb.out","w",stdout); part1::MAIN(); part2::work(); return 0;&#125; 不开O2要1.7秒，开O2要1.3秒，所以开了两秒时限。]]></content>
      <categories>
        <category>每月一题</category>
      </categories>
      <tags>
        <tag>cdq分治</tag>
        <tag>tarjan缩点</tag>
      </tags>
  </entry>
</search>
